// Sistema de Chat para Feedbacks
if (typeof FeedbackChat === 'undefined') {
class FeedbackChat {
    constructor() {
        this.currentFeedbackId = null;
        this.currentReplyTo = null;
        this.messages = [];
        this.isOpen = false;
        this.emojiPicker = null;
        this.reactionPicker = null;
        this.init();
    }

    init() {
        this.createEmojiPicker();
        this.setupEventListeners();
    }

    // Abrir chat para um feedback espec√≠fico
    async openChat(feedbackId) {
        try {
            console.log('üéØ FeedbackChat.openChat chamado com ID:', feedbackId);
            console.log('üéØ Estado atual - isOpen:', this.isOpen, 'currentFeedbackId:', this.currentFeedbackId);
            
            // Verificar se j√° existe um modal aberto
            const existingModal = document.querySelector('.feedback-chat-container');
            if (existingModal) {
                console.log('üéØ Modal existente encontrado, removendo...');
                existingModal.remove();
            }
            
            if (this.isOpen && this.currentFeedbackId === feedbackId) {
                console.log('üéØ Chat j√° est√° aberto para este feedback');
                return; // Chat j√° est√° aberto para este feedback
            }

            // Resetar estado
            this.currentFeedbackId = feedbackId;
            this.isOpen = true;
            this.currentReplyTo = null;
            
            console.log('üéØ Criando modal do chat...');
            await this.createChatModal();
            console.log('üéØ Carregando mensagens...');
            await this.loadMessages();
            console.log('üéØ Fazendo scroll para o final...');
            this.scrollToBottom();
            console.log('üéØ Chat aberto com sucesso');
        } catch (error) {
            console.error('‚ùå Erro ao abrir chat:', error);
            this.isOpen = false;
            this.currentFeedbackId = null;
        }
    }

    // Criar modal do chat
    async createChatModal() {
        try {
            console.log('üéØ Criando modal do chat...');
            
            // Remover modal existente se houver
            const existingModal = document.querySelector('.feedback-chat-container');
            if (existingModal) {
                console.log('üéØ Removendo modal existente');
                existingModal.remove();
            }

            // Buscar informa√ß√µes do feedback
            const feedbackInfo = await this.getFeedbackInfo(this.currentFeedbackId);
            this.feedbackInfo = feedbackInfo; // Armazenar para usar na renderiza√ß√£o
            
            console.log('Criando elemento modal...');
            const modal = document.createElement('div');
            modal.className = 'feedback-chat-container';
            
            // Verificar se est√° em modo gestor (somente leitura)
            const isManagerMode = this.isManagerMode || false;
            const inputSection = isManagerMode ? `
                <div class="chat-input-container manager-mode">
                    <div class="manager-notice">
                        <i class="fas fa-eye"></i>
                        <span>Modo visualiza√ß√£o - Voc√™ pode apenas visualizar as mensagens</span>
                    </div>
                </div>
            ` : `
                <div class="chat-input-container">
                    <div class="reply-preview" id="reply-preview">
                        <div class="reply-preview-text">Respondendo para:</div>
                        <div class="reply-preview-message" id="reply-preview-message"></div>
                        <button class="reply-cancel-btn" onclick="feedbackChat.cancelReply()">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                    
                    <div class="chat-input-wrapper">
                        <textarea 
                            class="chat-input" 
                            id="chat-input" 
                            placeholder="Digite sua mensagem..."
                            rows="1"
                        ></textarea>
                        
                        <div class="chat-input-actions">
                            <button class="emoji-btn" onclick="feedbackChat.toggleEmojiPicker()">
                                <i class="fas fa-smile"></i>
                            </button>
                            <button class="send-btn" id="send-btn" disabled>
                                <i class="fas fa-paper-plane"></i>
                            </button>
                        </div>
                    </div>
                </div>
            `;
            
            modal.innerHTML = `
            <div class="feedback-chat-modal">
                <div class="chat-header">
                    <h3>
                        <i class="fas fa-comments"></i>
                        Chat - ${feedbackInfo.title}
                        ${isManagerMode ? '<span class="manager-badge">Modo Gestor</span>' : ''}
                    </h3>
                    <div class="chat-header-actions">
                        <button class="chat-close-btn" onclick="feedbackChat.closeChat()">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                </div>
                
                <div class="chat-messages" id="chat-messages">
                    <div class="chat-loading">
                        <i class="fas fa-spinner fa-spin"></i>
                        Carregando mensagens...
                    </div>
                </div>
                
                ${inputSection}
            </div>
        `;

            console.log('üéØ Adicionando modal ao DOM...');
            document.body.appendChild(modal);
            console.log('üéØ Modal adicionado ao DOM');
            
            // Verificar se o modal foi realmente adicionado
            const addedModal = document.querySelector('.feedback-chat-container');
            if (addedModal) {
                console.log('üéØ Modal confirmado no DOM:', addedModal);
            } else {
                console.error('‚ùå Modal n√£o foi encontrado no DOM ap√≥s adicionar');
            }
            
            console.log('üéØ Configurando event listeners...');
            this.setupChatEventListeners();
            console.log('üéØ Modal do chat criado com sucesso');
        } catch (error) {
            console.error('Erro ao criar modal do chat:', error);
            throw error;
        }
    }

    // Buscar informa√ß√µes do feedback
    async getFeedbackInfo(feedbackId) {
        try {
            console.log('Buscando informa√ß√µes do feedback:', feedbackId);
            const response = await fetch(`/api/feedbacks/${feedbackId}/info`);
            if (response.ok) {
                const info = await response.json();
                console.log('Informa√ß√µes do feedback obtidas:', info);
                return info;
            } else {
                console.error('Erro na resposta da API:', response.status, response.statusText);
                const errorText = await response.text();
                console.error('Detalhes do erro:', errorText);
            }
        } catch (error) {
            console.error('Erro ao buscar info do feedback:', error);
        }
        
        console.log('Usando fallback para informa√ß√µes do feedback');
        return { title: `Feedback #${feedbackId}` }; // Fallback mais informativo
    }

    // Configurar event listeners do chat
    setupChatEventListeners() {
        try {
            console.log('Configurando event listeners do chat...');
            
            // Se estiver em modo gestor, n√£o configurar eventos de envio
            if (this.isManagerMode) {
                console.log('Modo gestor ativado - eventos de envio desabilitados');
                return;
            }
            
            const chatInput = document.getElementById('chat-input');
            const sendBtn = document.getElementById('send-btn');
            
            if (!chatInput) {
                console.error('Elemento chat-input n√£o encontrado');
                return;
            }
            
            if (!sendBtn) {
                console.error('Elemento send-btn n√£o encontrado');
                return;
            }
            
            console.log('Event listeners configurados com sucesso');

        // Auto-resize do textarea
        chatInput.addEventListener('input', () => {
            chatInput.style.height = 'auto';
            chatInput.style.height = Math.min(chatInput.scrollHeight, 120) + 'px';
            
            // Habilitar/desabilitar bot√£o enviar
            sendBtn.disabled = !chatInput.value.trim();
        });

        // Evento de clique no bot√£o enviar
        sendBtn.addEventListener('click', (e) => {
            e.preventDefault();
            if (chatInput.value.trim() && this.currentFeedbackId) {
                this.sendMessage();
            }
        });

        // Enviar com Enter (Shift+Enter para nova linha)
        chatInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                if (chatInput.value.trim() && this.currentFeedbackId) {
                    this.sendMessage();
                }
            }
        });

            // Fechar modal clicando fora
            document.querySelector('.feedback-chat-container').addEventListener('click', (e) => {
                if (e.target.classList.contains('feedback-chat-container')) {
                    this.closeChat();
                }
            });
        } catch (error) {
            console.error('Erro ao configurar event listeners:', error);
        }
    }

    // Carregar mensagens do chat
    async loadMessages() {
        try {
            // Primeiro, tentar criar as tabelas se necess√°rio
            await fetch('/api/chat/setup-tables', {
                method: 'POST',
                credentials: 'include'
            });
            
            const response = await fetch(`/api/feedbacks/${this.currentFeedbackId}/messages`);
            if (response.ok) {
                this.messages = await response.json();
                this.renderMessages();
            } else {
                const errorData = await response.json();
                console.error('Erro na resposta:', errorData);
                this.showEmptyState();
            }
        } catch (error) {
            console.error('Erro ao carregar mensagens:', error);
            this.showEmptyState();
        }
    }

    // Renderizar mensagens
    renderMessages() {
        const container = document.getElementById('chat-messages');
        
        if (this.messages.length === 0) {
            this.showEmptyState();
            return;
        }

        container.innerHTML = this.messages.map(message => this.renderMessage(message)).join('');
        
        // Adicionar event listeners para bot√µes de responder (apenas se n√£o estiver no modo gestor)
        if (!this.isManagerMode) {
            container.querySelectorAll('.reply-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const messageId = parseInt(btn.dataset.messageId);
                    const userName = btn.dataset.userName;
                    const messageText = btn.dataset.messageText;
                    this.replyToMessage(messageId, userName, messageText);
                });
            });
        }
        
        this.scrollToBottom();
    }

    // Renderizar uma mensagem individual
    renderMessage(message) {
        // No modo gestor, usar informa√ß√µes do feedback para identificar o remetente
        let isOwn = false;
        let senderName = message.user_name || 'Usu√°rio';
        
        if (this.isManagerMode && this.feedbackInfo) {
            // No modo gestor, comparar com os participantes do feedback
            isOwn = message.user_name === this.feedbackInfo.from;
            senderName = message.user_name;
        } else {
            // Modo normal - comparar com usu√°rio atual
            isOwn = message.user_id === currentUser.userId;
        }
        
        // Ajustar fuso hor√°rio: adicionar 3 horas para GMT-3 (Brasil)
        const messageDate = new Date(message.created_at);
        messageDate.setHours(messageDate.getHours() + 3);
        
        const messageTime = messageDate.toLocaleTimeString('pt-BR', {
            hour: '2-digit',
            minute: '2-digit'
        });

        let replyHtml = '';
        if (message.reply_to_message && message.reply_to_user) {
            console.log('üéØ Renderizando refer√™ncia de resposta:', {
                reply_to_message: message.reply_to_message,
                reply_to_user: message.reply_to_user
            });
            
            const shortMessage = message.reply_to_message.length > 100 ? 
                message.reply_to_message.substring(0, 100) + '...' : 
                message.reply_to_message;
            replyHtml = `
                <div class="reply-indicator">
                    <i class="fas fa-reply"></i>
                    <strong>${message.reply_to_user}:</strong> ${shortMessage}
                </div>
            `;
        } else {
            console.log('üéØ Mensagem sem refer√™ncia de resposta:', {
                reply_to_message: message.reply_to_message,
                reply_to_user: message.reply_to_user,
                message_id: message.Id
            });
        }



        return `
            <div class="chat-message ${isOwn ? 'own' : 'other'}" data-message-id="${message.Id}">
                ${replyHtml}
                <div class="message-bubble">
                    ${this.formatMessageText(message.message)}
                </div>
                <div class="message-info">
                    <div class="message-header">
                        <span class="message-sender">${senderName}</span>
                    <span class="message-time">${messageTime}</span>
                    </div>
                    ${!this.isManagerMode ? `
                        <div class="message-actions">
                            <button class="message-action-btn reply-btn" data-message-id="${message.Id}" data-user-name="${message.user_name}" data-message-text="${message.message}">
                                <i class="fas fa-reply"></i>
                                Responder
                            </button>
                        </div>
                    ` : ''}
                </div>

            </div>
        `;
    }

    // Agrupar rea√ß√µes por emoji
    groupReactions(reactions) {
        const groups = {};
        reactions.forEach(reaction => {
            if (!groups[reaction.emoji]) {
                groups[reaction.emoji] = [];
            }
            groups[reaction.emoji].push(reaction.user_id);
        });
        return groups;
    }

    // Formatar texto da mensagem (emojis, links, etc.)
    formatMessageText(text) {
        // Converter quebras de linha
        text = text.replace(/\n/g, '<br>');
        
        // Converter URLs em links
        const urlRegex = /(https?:\/\/[^\s]+)/g;
        text = text.replace(urlRegex, '<a href="$1" target="_blank" rel="noopener">$1</a>');
        
        return text;
    }

    // Mostrar estado vazio
    showEmptyState() {
        const container = document.getElementById('chat-messages');
        container.innerHTML = `
            <div class="chat-empty">
                <i class="fas fa-comments"></i>
                <p>Nenhuma mensagem ainda.</p>
                <p>Seja o primeiro a comentar!</p>
            </div>
        `;
    }

    // Enviar mensagem
    async sendMessage() {
        const input = document.getElementById('chat-input');
        const message = input.value.trim();
        
        console.log('üöÄ Iniciando envio - currentReplyTo:', this.currentReplyTo);
        
        if (!message || !this.currentFeedbackId) {
            console.error('Mensagem vazia ou feedbackId inv√°lido:', { message, feedbackId: this.currentFeedbackId });
            return;
        }

        const sendBtn = document.querySelector('.send-btn');
        sendBtn.disabled = true;
        sendBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';

        try {
            const payload = {
                message,
                reply_to: this.currentReplyTo
            };
            
            console.log('üì§ Payload sendo enviado:', payload);
            console.log('üì§ currentReplyTo:', this.currentReplyTo);
            console.log('üì§ Tipo de reply_to:', typeof this.currentReplyTo);
            
            const response = await fetch(`/api/feedbacks/${this.currentFeedbackId}/messages`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                credentials: 'include',
                body: JSON.stringify(payload)
            });

            if (response.ok) {
                const result = await response.json();
                
                input.value = '';
                input.style.height = 'auto';
                this.currentReplyTo = null; // Limpar apenas o estado, n√£o chamar cancelReply()
                document.getElementById('reply-preview').classList.remove('show'); // Esconder preview
                await this.loadMessages();
                // Atualizar contagem de mensagens no feedback principal
                this.updateFeedbackMessageCount(result.pointsEarned);
                
                // Atualizar pontos do usu√°rio se ganhou pontos com a resposta
                console.log('üéØ Resultado da resposta:', result);
                if (result.pointsEarned > 0) {
                    console.log(`üéâ Usu√°rio ganhou ${result.pointsEarned} pontos!`);
                    // Atualizar dados de gamifica√ß√£o
                    await this.updateUserPoints(result.pointsEarned);
                    
                    // Mostrar notifica√ß√£o de pontos ganhos
                    this.showPointsNotification(result.pointsEarned);
                } else {
                    console.log('‚ÑπÔ∏è Nenhum ponto ganho com esta resposta');
                    // N√£o mostrar notifica√ß√£o quando n√£o ganha pontos
                }
            } else {
                const error = await response.json();
                console.error('Erro na resposta:', error);
                alert(error.error || 'Erro ao enviar mensagem');
            }
        } catch (error) {
            console.error('Erro ao enviar mensagem:', error);
            alert('Erro ao enviar mensagem');
        } finally {
            sendBtn.disabled = false;
            sendBtn.innerHTML = '<i class="fas fa-paper-plane"></i>';
        }
    }

    // Responder a uma mensagem
    replyToMessage(messageId, userName, messageText) {
        console.log('üîÑ Definindo reply_to:', messageId);
        this.currentReplyTo = messageId;
        
        const replyPreview = document.getElementById('reply-preview');
        const replyMessage = document.getElementById('reply-preview-message');
        
        replyMessage.innerHTML = `<strong>${userName}:</strong> ${messageText.substring(0, 100)}${messageText.length > 100 ? '...' : ''}`;
        replyPreview.classList.add('show');
        
        document.getElementById('chat-input').focus();
        
        console.log('‚úÖ currentReplyTo definido como:', this.currentReplyTo);
    }

    // Cancelar resposta
    cancelReply() {
        console.log('üîÑ Cancelando resposta, currentReplyTo era:', this.currentReplyTo);
        this.currentReplyTo = null;
        document.getElementById('reply-preview').classList.remove('show');
        console.log('‚úÖ Resposta cancelada, currentReplyTo agora √©:', this.currentReplyTo);
    }

    // Mostrar picker de rea√ß√µes
    showReactionPicker(event, messageId) {
        event.stopPropagation();
        
        // Remover picker existente
        const existingPicker = document.querySelector('.reaction-picker');
        if (existingPicker) {
            existingPicker.remove();
        }

        const picker = document.createElement('div');
        picker.className = 'reaction-picker show';
        picker.innerHTML = `
            <div class="reaction-option" onclick="feedbackChat.addReaction(${messageId}, 'üëç')">üëç</div>
            <div class="reaction-option" onclick="feedbackChat.addReaction(${messageId}, '‚ù§Ô∏è')">‚ù§Ô∏è</div>
            <div class="reaction-option" onclick="feedbackChat.addReaction(${messageId}, 'üòä')">üòä</div>
            <div class="reaction-option" onclick="feedbackChat.addReaction(${messageId}, 'üëè')">üëè</div>
            <div class="reaction-option" onclick="feedbackChat.addReaction(${messageId}, 'üéâ')">üéâ</div>
            <div class="reaction-option" onclick="feedbackChat.addReaction(${messageId}, 'üí°')">üí°</div>
        `;

        // Posicionar picker
        const rect = event.target.getBoundingClientRect();
        picker.style.position = 'fixed';
        picker.style.top = (rect.top - 50) + 'px';
        picker.style.left = rect.left + 'px';

        document.body.appendChild(picker);

        // Remover picker ao clicar fora
        setTimeout(() => {
            document.addEventListener('click', function removePicker() {
                picker.remove();
                document.removeEventListener('click', removePicker);
            });
        }, 100);
    }

    // Adicionar rea√ß√£o
    async addReaction(messageId, emoji) {
        try {
            const response = await fetch(`/api/feedbacks/messages/${messageId}/react`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                credentials: 'include',
                body: JSON.stringify({ emoji })
            });

            if (response.ok) {
                await this.loadMessages();
            }
        } catch (error) {
            console.error('Erro ao adicionar rea√ß√£o:', error);
        }

        // Remover picker
        const picker = document.querySelector('.reaction-picker');
        if (picker) picker.remove();
    }

    // Toggle rea√ß√£o existente
    async toggleReaction(messageId, emoji) {
        try {
            const response = await fetch(`/api/feedbacks/messages/${messageId}/react`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                credentials: 'include',
                body: JSON.stringify({ emoji })
            });

            if (response.ok) {
                await this.loadMessages();
            }
        } catch (error) {
            console.error('Erro ao toggle rea√ß√£o:', error);
        }
    }

    // Criar picker de emojis
    createEmojiPicker() {
        const emojis = [
            'üòÄ', 'üòÉ', 'üòÑ', 'üòÅ', 'üòÜ', 'üòÖ', 'üòÇ', 'ü§£',
            'üòä', 'üòá', 'üôÇ', 'üôÉ', 'üòâ', 'üòå', 'üòç', 'ü•∞',
            'üòò', 'üòó', 'üòô', 'üòö', 'üòã', 'üòõ', 'üòù', 'üòú',
            'ü§™', 'ü§®', 'üßê', 'ü§ì', 'üòé', 'ü§©', 'ü•≥', 'üòè',
            'üëç', 'üëé', 'üëå', '‚úåÔ∏è', 'ü§û', 'ü§ü', 'ü§ò', 'ü§ô',
            'üëà', 'üëâ', 'üëÜ', 'üëá', '‚òùÔ∏è', '‚úã', 'ü§ö', 'üñêÔ∏è',
            'üññ', 'üëã', 'ü§è', 'üí™', 'ü¶æ', 'üñï', '‚úçÔ∏è', 'üôè',
            '‚ù§Ô∏è', 'üß°', 'üíõ', 'üíö', 'üíô', 'üíú', 'üñ§', 'ü§ç',
            'ü§é', 'üíî', '‚ù£Ô∏è', 'üíï', 'üíû', 'üíì', 'üíó', 'üíñ',
            'üíò', 'üíù', 'üíü', '‚òÆÔ∏è', '‚úùÔ∏è', '‚ò™Ô∏è', 'üïâÔ∏è', '‚ò∏Ô∏è',
            'üéâ', 'üéä', 'üéà', 'üéÅ', 'üéÄ', 'üéÇ', 'üç∞', 'üßÅ',
            'üî•', 'üíØ', 'üí´', '‚≠ê', 'üåü', '‚ú®', '‚ö°', 'üí•'
        ];

        this.emojiList = emojis;
    }

    // Toggle picker de emojis
    toggleEmojiPicker() {
        const existingPicker = document.querySelector('.emoji-picker');
        
        if (existingPicker) {
            existingPicker.remove();
            return;
        }

        const picker = document.createElement('div');
        picker.className = 'emoji-picker show';
        picker.innerHTML = `
            <div class="emoji-picker-header">Escolha um emoji</div>
            <div class="emoji-grid">
                ${this.emojiList.map(emoji => `
                    <div class="emoji-item" onclick="feedbackChat.insertEmoji('${emoji}')">${emoji}</div>
                `).join('')}
            </div>
        `;

        document.querySelector('.chat-input-container').appendChild(picker);

        // Fechar ao clicar fora
        setTimeout(() => {
            document.addEventListener('click', function closePicker(e) {
                if (!e.target.closest('.emoji-picker') && !e.target.closest('.emoji-btn')) {
                    picker.remove();
                    document.removeEventListener('click', closePicker);
                }
            });
        }, 100);
    }

    // Inserir emoji no input
    insertEmoji(emoji) {
        const input = document.getElementById('chat-input');
        const cursorPos = input.selectionStart;
        const textBefore = input.value.substring(0, cursorPos);
        const textAfter = input.value.substring(cursorPos);
        
        input.value = textBefore + emoji + textAfter;
        input.focus();
        input.setSelectionRange(cursorPos + emoji.length, cursorPos + emoji.length);
        
        // Trigger input event para atualizar bot√£o
        input.dispatchEvent(new Event('input'));
        
        // Fechar picker
        const picker = document.querySelector('.emoji-picker');
        if (picker) picker.remove();
    }

    // Scroll para o final
    scrollToBottom() {
        const container = document.getElementById('chat-messages');
        if (container) {
            container.scrollTop = container.scrollHeight;
        }
    }

    // Fechar chat
    closeChat() {
        console.log('üéØ Fechando chat...');
        
        const modal = document.querySelector('.feedback-chat-container');
        if (modal) {
            console.log('üéØ Removendo modal do DOM');
            modal.remove();
        }
        
        // Limpar estado completamente
        this.isOpen = false;
        this.currentFeedbackId = null;
        this.currentReplyTo = null;
        this.messages = [];
        this.isManagerMode = false; // Resetar modo gestor
        
        // Limpar emoji picker se existir
        if (this.emojiPicker) {
            this.emojiPicker.remove();
            this.emojiPicker = null;
        }
        
        // Limpar reaction picker se existir
        if (this.reactionPicker) {
            this.reactionPicker.remove();
            this.reactionPicker = null;
        }
        
        console.log('üéØ Chat fechado e estado limpo');
    }

    // Event listeners globais
    setupEventListeners() {
        // Fechar com ESC
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && this.isOpen) {
                this.closeChat();
            }
        });
    }

    // Atualizar contagem de mensagens no feedback principal
    updateFeedbackMessageCount(pointsEarned = 0) {
        if (this.currentFeedbackId) {
            // Buscar o card do feedback atual
            const feedbackItem = document.querySelector(`[data-feedback-id="${this.currentFeedbackId}"]`);
            if (feedbackItem) {
                // Atualizar contador de respostas
                const replyButton = feedbackItem.querySelector('.status-respostas .counter');
                if (replyButton) {
                    // Incrementar contador
                    const currentCount = parseInt(replyButton.textContent) || 0;
                    replyButton.textContent = currentCount + 1;
                    
                    // Adicionar classe de atividade se n√£o existir
                    const replyButtonContainer = feedbackItem.querySelector('.status-respostas');
                    if (replyButtonContainer) {
                        replyButtonContainer.classList.add('has-activity');
                    }
                }
                
                // Atualizar status dos pontos apenas se ganhou pontos
                if (pointsEarned > 0) {
                    console.log(`üéØ Ganhou ${pointsEarned} pontos - atualizando status do card`);
                    // Tentar atualiza√ß√£o imediata
                    this.updateFeedbackPointsStatus(feedbackItem);
                    
                    // M√∫ltiplos delays para garantir que o DOM foi atualizado
                    setTimeout(() => {
                        this.updateFeedbackPointsStatus(feedbackItem);
                    }, 100);
                    
                    // Backup com delay maior
                    setTimeout(() => {
                        this.updateFeedbackPointsStatusAlternative();
                    }, 500);
                    
                    // √öltimo recurso com delay ainda maior
                    setTimeout(() => {
                        this.forceUpdateFeedbackPoints();
                    }, 1000);
                    
                    // Verifica√ß√£o final para garantir que foi atualizado
                    setTimeout(() => {
                        this.verifyPointsUpdate();
                    }, 1500);
                } else {
                    console.log('‚ÑπÔ∏è Nenhum ponto ganho - n√£o atualizando status do card');
                }
            }
        }
    }

    // Atualizar status dos pontos no card do feedback
    updateFeedbackPointsStatus(feedbackItem) {
        // Verificar se estamos na aba de feedbacks recebidos
        // (onde o usu√°rio pode ganhar pontos respondendo)
        const isReceivedTab = window.currentFeedbackTab === 'received';
        
        if (!isReceivedTab) {
            console.log('‚ÑπÔ∏è N√£o √© uma aba de feedbacks recebidos, n√£o atualizando status de pontos');
            return;
        }
        
        console.log('üéØ Iniciando atualiza√ß√£o do status de pontos...');
        console.log('üéØ Feedback ID:', this.currentFeedbackId);
        console.log('üéØ feedbackItem recebido:', feedbackItem);
        
        // Buscar o elemento de pontos de diferentes formas para garantir que encontre
        let pointsElement = this.findPointsElement(feedbackItem);
        
        if (pointsElement) {
            console.log('üéØ Elemento de pontos encontrado:', pointsElement);
            console.log('üéØ Texto atual:', pointsElement.textContent);
            
            // Verificar se o elemento ainda mostra "Sem pontos"
            if (pointsElement.textContent.includes('Sem pontos')) {
                // Atualizar para mostrar que ganhou pontos
                pointsElement.textContent = '+10 pontos';
                pointsElement.classList.add('earned');
                
                // Adicionar anima√ß√£o de destaque
                pointsElement.style.animation = 'pointsUpdate 0.5s ease-in-out';
                setTimeout(() => {
                    pointsElement.style.animation = '';
                }, 500);
                
                console.log('‚úÖ Status de pontos atualizado no card do feedback: Sem pontos ‚Üí +10 pontos');
            } else {
                console.log('‚ÑπÔ∏è Status de pontos j√° estava correto no card do feedback');
            }
        } else {
            console.log('‚ö†Ô∏è Elemento de pontos n√£o encontrado no card do feedback');
            // Tentar uma abordagem alternativa - buscar diretamente pelo ID
            this.updateFeedbackPointsStatusAlternative();
        }
    }

    // M√©todo alternativo para atualizar status de pontos
    updateFeedbackPointsStatusAlternative() {
        console.log('üîÑ Tentando m√©todo alternativo para atualizar pontos...');
        
        // Buscar diretamente pelo ID do feedback
        const feedbackElement = document.querySelector(`[data-feedback-id="${this.currentFeedbackId}"]`);
        if (feedbackElement) {
            console.log('üîÑ Elemento do feedback encontrado:', feedbackElement);
            
            const pointsElement = feedbackElement.querySelector('.points-info');
            if (pointsElement) {
                console.log('üîÑ Elemento de pontos encontrado (m√©todo alternativo):', pointsElement);
                console.log('üîÑ Texto atual:', pointsElement.textContent);
                
                if (pointsElement.textContent.includes('Sem pontos')) {
                    pointsElement.textContent = '+10 pontos';
                    pointsElement.classList.add('earned');
                    
                    // Adicionar anima√ß√£o de destaque
                    pointsElement.style.animation = 'pointsUpdate 0.5s ease-in-out';
                    setTimeout(() => {
                        pointsElement.style.animation = '';
                    }, 500);
                    
                    console.log('‚úÖ Status de pontos atualizado (m√©todo alternativo): Sem pontos ‚Üí +10 pontos');
                } else {
                    console.log('‚ÑπÔ∏è Status de pontos j√° estava correto (m√©todo alternativo)');
                }
            } else {
                console.log('‚ùå Elemento de pontos n√£o encontrado (m√©todo alternativo)');
            }
        } else {
            console.log('‚ùå Elemento do feedback n√£o encontrado (m√©todo alternativo)');
        }
    }

    // Fun√ß√£o auxiliar para encontrar o elemento de pontos
    findPointsElement(feedbackItem) {
        console.log('üîç Buscando elemento de pontos para feedback:', this.currentFeedbackId);
        console.log('üîç feedbackItem:', feedbackItem);
        
        // Tentar diferentes seletores para encontrar o elemento de pontos
        const selectors = [
            '.points-info',
            '.feedback-points .points-info',
            '.feedback-points span',
            '[class*="points"]'
        ];
        
        for (const selector of selectors) {
            console.log(`üîç Tentando seletor: ${selector}`);
            let element = feedbackItem.querySelector(selector);
            
            // Se n√£o encontrou, tentar buscar no elemento pai (feedback-item)
            if (!element) {
                const feedbackItemParent = feedbackItem.closest('.feedback-item');
                if (feedbackItemParent) {
                    console.log('üîç Buscando no elemento pai:', feedbackItemParent);
                    element = feedbackItemParent.querySelector(selector);
                }
            }
            
            console.log(`üîç Elemento encontrado com seletor ${selector}:`, element);
            
            // Se encontrou um elemento que cont√©m texto relacionado a pontos
            if (element && (element.textContent.includes('pontos') || element.textContent.includes('Sem pontos'))) {
                console.log('‚úÖ Elemento de pontos encontrado:', element, 'Texto:', element.textContent);
                return element;
            }
        }
        
        // Se n√£o encontrou com os seletores, tentar buscar por ID do feedback
        console.log('üîç Tentando busca por ID do feedback...');
        const feedbackElement = document.querySelector(`[data-feedback-id="${this.currentFeedbackId}"]`);
        if (feedbackElement) {
            console.log('üîç Elemento do feedback encontrado por ID:', feedbackElement);
            const pointsElement = feedbackElement.querySelector('.points-info');
            if (pointsElement) {
                console.log('‚úÖ Elemento de pontos encontrado por ID:', pointsElement, 'Texto:', pointsElement.textContent);
                return pointsElement;
            }
        }
        
        console.log('‚ùå Elemento de pontos n√£o encontrado');
        return null;
    }

    // √öltimo recurso para for√ßar atualiza√ß√£o dos pontos
    forceUpdateFeedbackPoints() {
        console.log('üöÄ For√ßando atualiza√ß√£o dos pontos (√∫ltimo recurso)...');
        
        // Buscar todos os elementos de pontos na p√°gina
        const allPointsElements = document.querySelectorAll('.points-info');
        console.log('üöÄ Todos os elementos de pontos encontrados:', allPointsElements.length);
        
        // Procurar especificamente pelo feedback atual
        const feedbackElement = document.querySelector(`[data-feedback-id="${this.currentFeedbackId}"]`);
        if (feedbackElement) {
            console.log('üöÄ Elemento do feedback encontrado (for√ßado):', feedbackElement);
            
            const pointsElement = feedbackElement.querySelector('.points-info');
            if (pointsElement) {
                console.log('üöÄ Elemento de pontos encontrado (for√ßado):', pointsElement);
                console.log('üöÄ Texto atual:', pointsElement.textContent);
                
                if (pointsElement.textContent.includes('Sem pontos')) {
                    pointsElement.textContent = '+10 pontos';
                    pointsElement.classList.add('earned');
                    
                    // Adicionar anima√ß√£o de destaque
                    pointsElement.style.animation = 'pointsUpdate 0.5s ease-in-out';
                    setTimeout(() => {
                        pointsElement.style.animation = '';
                    }, 500);
                    
                    console.log('‚úÖ Status de pontos atualizado (for√ßado): Sem pontos ‚Üí +10 pontos');
                } else {
                    console.log('‚ÑπÔ∏è Status de pontos j√° estava correto (for√ßado)');
                }
            } else {
                console.log('‚ùå Elemento de pontos n√£o encontrado (for√ßado)');
            }
        } else {
            console.log('‚ùå Elemento do feedback n√£o encontrado (for√ßado)');
        }
    }

    // Verificar se a atualiza√ß√£o dos pontos foi bem-sucedida
    verifyPointsUpdate() {
        console.log('üîç Verificando se a atualiza√ß√£o dos pontos foi bem-sucedida...');
        
        const feedbackElement = document.querySelector(`[data-feedback-id="${this.currentFeedbackId}"]`);
        if (feedbackElement) {
            const pointsElement = feedbackElement.querySelector('.points-info');
            if (pointsElement) {
                console.log('üîç Status atual dos pontos:', pointsElement.textContent);
                
                if (pointsElement.textContent.includes('Sem pontos')) {
                    console.log('‚ö†Ô∏è A atualiza√ß√£o n√£o foi bem-sucedida, tentando novamente...');
                    // Tentar uma √∫ltima vez
                    pointsElement.textContent = '+10 pontos';
                    pointsElement.classList.add('earned');
                    pointsElement.style.animation = 'pointsUpdate 0.5s ease-in-out';
                    setTimeout(() => {
                        pointsElement.style.animation = '';
                    }, 500);
                    console.log('‚úÖ Atualiza√ß√£o for√ßada realizada');
                } else {
                    console.log('‚úÖ Atualiza√ß√£o dos pontos foi bem-sucedida');
                }
            }
        }
    }

    // Atualizar pontos do usu√°rio ap√≥s ganhar pontos
    async updateUserPoints(pointsEarned) {
        try {
            // Atualizar dados de gamifica√ß√£o
            if (typeof window.loadGamificationData === 'function') {
                await window.loadGamificationData();
            } else if (typeof loadGamificationData === 'function') {
                await loadGamificationData();
            }
            
            // Atualizar m√©tricas do dashboard
            if (typeof window.loadMetrics === 'function') {
                await window.loadMetrics();
            } else if (typeof loadMetrics === 'function') {
                await loadMetrics();
            }
            
            // Atualizar contador de pontos no header se existir
            const pointsElement = document.getElementById('user-points');
            if (pointsElement) {
                const currentPoints = parseInt(pointsElement.textContent) || 0;
                pointsElement.textContent = currentPoints + pointsEarned;
                
                // Adicionar anima√ß√£o de destaque
                pointsElement.style.animation = 'pointsUpdate 0.5s ease-in-out';
                setTimeout(() => {
                    pointsElement.style.animation = '';
                }, 500);
            }
            
            console.log(`‚úÖ Pontos atualizados: +${pointsEarned} pontos`);
        } catch (error) {
            console.error('Erro ao atualizar pontos:', error);
        }
    }

    // Mostrar notifica√ß√£o de pontos ganhos
    showPointsNotification(pointsEarned) {
        // Remover notifica√ß√£o existente se houver
        const existingNotification = document.querySelector('.points-notification');
        if (existingNotification) {
            existingNotification.remove();
        }

        // Criar notifica√ß√£o
        const notification = document.createElement('div');
        notification.className = 'points-notification show';
        notification.innerHTML = `
            <div class="points-notification-content">
                <div class="points-notification-icon">
                    <i class="fas fa-star"></i>
                </div>
                <div class="points-notification-text">
                    <div class="points-notification-title">Pontos Ganhos!</div>
                    <div class="points-notification-message">+${pointsEarned} pontos por responder ao feedback</div>
                </div>
                <button class="points-notification-close" onclick="this.parentElement.parentElement.remove()">
                    <i class="fas fa-times"></i>
                </button>
            </div>
        `;

        // Adicionar ao body
        document.body.appendChild(notification);

        // Auto-remover ap√≥s 5 segundos
        setTimeout(() => {
            if (notification && notification.parentElement) {
                notification.classList.remove('show');
                setTimeout(() => {
                    if (notification && notification.parentElement) {
                        notification.remove();
                    }
                }, 300);
            }
        }, 5000);
    }

    // Mostrar notifica√ß√£o informativa
    showInfoNotification(message) {
        // Remover notifica√ß√£o existente se houver
        const existingNotification = document.querySelector('.generic-notification');
        if (existingNotification) {
            existingNotification.remove();
        }

        const notification = document.createElement('div');
        notification.className = 'generic-notification show';
        notification.innerHTML = `
            <div class="generic-notification-content">
                <i class="fas fa-info-circle"></i>
                <span>${message}</span>
            </div>
        `;

        document.body.appendChild(notification);

        // Remover ap√≥s 4 segundos
        setTimeout(() => {
            if (notification.parentNode) {
                notification.classList.remove('show');
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.remove();
                    }
                }, 300);
            }
        }, 4000);
    }
}

    // Exportar para uso em outros arquivos
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = FeedbackChat;
    }

    // Expor globalmente
    window.FeedbackChat = FeedbackChat;
} // Fechar o bloco if (typeof FeedbackChat === 'undefined')

// Inst√¢ncia global do chat
const feedbackChat = new FeedbackChat();
window.feedbackChat = feedbackChat;

// Fun√ß√£o global para abrir chat (chamada pelos bot√µes de responder)
window.toggleFeedbackChat = function(feedbackId) {
    console.log('üéØ toggleFeedbackChat chamado com ID:', feedbackId);
    console.log('üéØ window.feedbackChat existe?', !!window.feedbackChat);
    
    if (window.feedbackChat) {
        console.log('üéØ Chamando openChat...');
        window.feedbackChat.openChat(feedbackId);
    } else {
        console.error('‚ùå Sistema de chat n√£o carregado');
        console.log('üéØ Tentando inicializar FeedbackChat...');
        
        if (typeof FeedbackChat !== 'undefined') {
            window.feedbackChat = new FeedbackChat();
            console.log('üéØ FeedbackChat inicializado:', window.feedbackChat);
            window.feedbackChat.openChat(feedbackId);
        } else {
            console.error('‚ùå Classe FeedbackChat n√£o est√° dispon√≠vel');
        }
    }
};